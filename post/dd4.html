<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>蒜法 | Ra-Liz's Blog</title><meta name="author" content="Ra-liz"><meta name="copyright" content="Ra-liz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二分查找704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4示例 2: 输入: nums &#x3D; [-1,0,3,5,">
<meta property="og:type" content="article">
<meta property="og:title" content="蒜法">
<meta property="og:url" content="https://ra-liz.github.io/post/dd4.html">
<meta property="og:site_name" content="Ra-Liz&#39;s Blog">
<meta property="og:description" content="二分查找704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4示例 2: 输入: nums &#x3D; [-1,0,3,5,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ra-liz.github.io/img/favicon.png">
<meta property="article:published_time" content="2023-03-20T01:19:27.000Z">
<meta property="article:modified_time" content="2023-03-27T02:13:13.826Z">
<meta property="article:author" content="Ra-liz">
<meta property="article:tag" content="二分查找">
<meta property="article:tag" content="双指针">
<meta property="article:tag" content="滑动窗口">
<meta property="article:tag" content="哈希表">
<meta property="article:tag" content="BFS">
<meta property="article:tag" content="DFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ra-liz.github.io/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ra-liz.github.io/post/dd4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '蒜法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 10:13:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Ra-Liz's Blog"><span class="site-name">Ra-Liz's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">蒜法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-20T01:19:27.000Z" title="发表于 2023-03-20 09:19:27">2023-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T02:13:13.826Z" title="更新于 2023-03-27 10:13:13">2023-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="蒜法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">704. 二分查找</a></h3><blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p>
<p>提示：</p>
<p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p>
</blockquote>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">left</span>:<span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">right</span>:<span class="built_in">number</span> = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">mid</span>:<span class="built_in">number</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>((right-left)/<span class="number">2</span>)+left</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = nums[mid]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; num) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; num) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">278. 第一个错误的版本</a></h3><blockquote>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例 1：</p>
<p>输入：n = 5, bad = 4<br>输出：4<br>解释：<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。<br>示例 2：</p>
<p>输入：n = 1, bad = 1<br>输出：1</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="comment"> * @param   version   your guess about first bad version</span></span><br><span class="line"><span class="comment"> * @return 	 	      true if current version is bad </span></span><br><span class="line"><span class="comment"> *			          false if current version is good</span></span><br><span class="line"><span class="comment"> * func isBadVersion(version int) bool;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstBadVersion</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, n</span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isBadVersion(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">35. 搜索插入位置</a></h3><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>示例 1:</p>
<p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums = [1,3,5,6], target = 7<br>输出: 4</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left+(right-left)/<span class="number">2</span></span><br><span class="line">        num := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> target == num &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target &gt; num &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target &lt; num &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">977. 有序数组的平方</a></h3><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p>
<p>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left,right,i := <span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(left &lt;= right) &#123;</span><br><span class="line">        leftVal := nums[left]*nums[left]</span><br><span class="line">        rightVal := nums[right]*nums[right]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftVal &gt; rightVal) &#123;</span><br><span class="line">            arr[i] = leftVal</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[i] = rightVal</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        i--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">189. 轮转数组</a></h3><blockquote>
<p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums = [-1,-100,3,99], k = 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">unshift</span>(nums.<span class="title function_">pop</span>());</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">283. 移动零</a></h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1:</p>
<p>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums = [0]<br>输出: [0]</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    cnt, low, fast := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fast] == <span class="number">0</span> &#123;</span><br><span class="line">            fast++</span><br><span class="line">            cnt++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[low] = nums[fast]</span><br><span class="line">            low++</span><br><span class="line">            fast++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := <span class="built_in">len</span>(nums)-cnt</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">167. 两数之和 II - 输入有序数组</a></h3><blockquote>
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<p>示例 1：</p>
<p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。<br>示例 2：</p>
<p>输入：numbers = [2,3,4], target = 6<br>输出：[1,3]<br>解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。<br>示例 3：</p>
<p>输入：numbers = [-1,0], target = -1<br>输出：[1,2]<br>解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        lVal, rVal := numbers[left], numbers[right]</span><br><span class="line">        sum := lVal+rVal</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">344. 反转字符串</a></h3><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>示例 1：</p>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="type">byte</span>)</span></span>  &#123;</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line">        temp := s[start]</span><br><span class="line">        s[start] = s[end]</span><br><span class="line">        s[end] = temp</span><br><span class="line">        start++</span><br><span class="line">        end--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">557. 反转字符串中的单词 III</a></h3><blockquote>
<p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p>示例 1：</p>
<p>输入：s = “Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”<br>示例 2:</p>
<p>输入： s = “God Ding”<br>输出：”doG gniD”</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    end,cnt := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    arr := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span> != <span class="built_in">len</span>(s)) &amp;&amp; (s[i+<span class="number">1</span>]!=<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            cnt++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        end = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= cnt; j++ &#123;</span><br><span class="line">            arr = <span class="built_in">append</span>(arr, s[end-j])</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span>!=<span class="built_in">len</span>(s) &#123;</span><br><span class="line">            arr = <span class="built_in">append</span>(arr, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">876. 链表的中间结点</a></h3><blockquote>
<p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/lc-midlist1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5]<br>输出：[3,4,5]<br>解释：链表只有一个中间结点，值为 3 。<br>示例 2：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/lc-midlist2.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5,6]<br>输出：[4,5,6]<br>解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast!=<span class="literal">nil</span> &amp;&amp; fast.Next!=<span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">19. 删除链表的倒数第 N 个结点</a></h3><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/remove_ex1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1,2], n = 1<br>输出：[1]</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">    slow, fast := dummy, dummy</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next!=<span class="literal">nil</span> &amp;&amp; fast!=<span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">3. 无重复字符的最长子串</a></h3><h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">567. 字符串的排列</a></h3><h2 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS/DFS"></a>BFS/DFS</h2><h3 id="🧩733-图像渲染"><a href="#🧩733-图像渲染" class="headerlink" title="🧩733. 图像渲染"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flood-fill/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🧩733. 图像渲染</a></h3><blockquote>
<p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p>
<p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr[sc 开始对图像进行 上色填充 。</p>
<p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p>
<p>最后返回 经过上色渲染后的图像 。</p>
<p> <img src="../images/%E8%92%9C%E6%B3%95/flood1-grid.jpg" alt="img"></p>
<p>示例 1:</p>
<p>输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2<br>输出: [[2,2,2],[2,2,0],[2,0,1]]<br>解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。<br>示例 2:</p>
<p>输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2<br>输出: [[2,2,2],[2,2,2]]</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一个BFS/DFS典中典题！</p>
<p>已知：题目已经告诉我们 图像数组<code>image(行列m*n)</code>，起始点<code>(sr, sc)</code>，需求色<code>color</code>。</p>
<p>要求：将从该点起步，将<code>自身</code>以及<code>其上/下/左/右方向上相邻色块</code>中，不同于需求颜色的原始色更改，最后返回image数组。</p>
<p>思路(BFS)：</p>
<ol>
<li>判断起始点颜色是否为需求色color。如果是，直接返回数组；反之，存储原始色rawColor，并将数组中对应值改为color值。</li>
<li>我们初始化一个队列<code>queue = [&#123;x: sr, y: rc&#125;]</code>，用于存放  被搜寻到的 且 颜色为rawColor  的色块。</li>
<li>接下来我们详细阐述此题广搜步骤：<ol>
<li>将队列中首元素提出，颜色改为color值</li>
<li>分别搜索该元素<code>上/下/左/右(对应x/y增减，四种)</code>块中是rawColor且在图片范围内的元素，随后将其加入队列中，并改颜色</li>
<li>由于我们在这一次的搜索中，遍历了某一层元素的<code>下一层元素</code>，那么在下一次搜索中，我们需要将<code>该层</code>元素提取出来进行搜索</li>
<li>直至全部搜寻到(介时队列为空，长度为0)</li>
</ol>
</li>
</ol>
<p>以下是我算是 第一次用JS写BFS 代码+注释↓</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">var</span> floodFill = <span class="keyword">function</span>(<span class="params">image, sr, sc, color</span>) &#123;</span><br><span class="line">    <span class="comment">// 起始点颜色</span></span><br><span class="line">    <span class="keyword">let</span> rawColor = image[sr][sc]</span><br><span class="line">    <span class="comment">// 如果颜色一样直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (rawColor === color) &#123;</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不一样，开始广搜</span></span><br><span class="line">    <span class="keyword">let</span> queue = [&#123;<span class="attr">x</span>:sr, <span class="attr">y</span>:sc&#125;],<span class="comment">// 符合条件的像素块组成的队列（范围内，相邻，是起始颜色）</span></span><br><span class="line">        dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>],<span class="comment">// 位移坐标</span></span><br><span class="line">        dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        rowLen = image.<span class="property">length</span>,<span class="comment">// 图画长宽-图画边框范围</span></span><br><span class="line">        colLen = image[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列中首元素pop</span></span><br><span class="line">        <span class="keyword">let</span> &#123;x, y&#125; = queue.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="comment">// 首元素改颜色</span></span><br><span class="line">        image[x][y] = color</span><br><span class="line">        <span class="comment">// 该元素相邻搜一下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素坐标</span></span><br><span class="line">            <span class="keyword">let</span> newX = x+dx[i], newY = y+dy[i]</span><br><span class="line">            <span class="comment">// 在画框范围内，且为起始颜色</span></span><br><span class="line">            <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;rowLen &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;colLen &amp;&amp; image[newX][newY] == rawColor) &#123;</span><br><span class="line">                <span class="comment">// 添加到队列中</span></span><br><span class="line">                queue.<span class="title function_">push</span>(&#123;<span class="attr">x</span>: newX, <span class="attr">y</span>: newY&#125;)</span><br><span class="line">                <span class="comment">// 且改变为要求颜色</span></span><br><span class="line">                image[newX][newY] = color</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>这位佬写的代码超级简洁且优雅↓</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">image</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">sr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">sc</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">color</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">floodFill</span> = (<span class="params">image, sr, sc, newColor</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> m = image.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = image[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> oldColor = image[sr][sc];</span><br><span class="line">    <span class="keyword">if</span> (oldColor == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fill</span> = (<span class="params">i, j</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || image[i][j] != oldColor) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image[i][j] = newColor;</span><br><span class="line">        <span class="title function_">fill</span>(i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="title function_">fill</span>(i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="title function_">fill</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">fill</span>(i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fill</span>(sr, sc);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">floodFill</span> = (<span class="params">image, sr, sc, newColor</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> m = image.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = image[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> oldColor = image[sr][sc];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldColor == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = [[sr, sc]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [i, j] = queue.<span class="title function_">shift</span>();</span><br><span class="line">        image[i][j] = newColor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; image[i - <span class="number">1</span>][j] == oldColor) queue.<span class="title function_">push</span>([i - <span class="number">1</span>, j]);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m &amp;&amp; image[i + <span class="number">1</span>][j] == oldColor) queue.<span class="title function_">push</span>([i + <span class="number">1</span>, j]);</span><br><span class="line">        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; image[i][j - <span class="number">1</span>] == oldColor) queue.<span class="title function_">push</span>([i, j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; image[i][j + <span class="number">1</span>] == oldColor) queue.<span class="title function_">push</span>([i, j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🏝695-岛屿的最大面积"><a href="#🏝695-岛屿的最大面积" class="headerlink" title="🏝695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🏝695. 岛屿的最大面积</a></h3><blockquote>
<p>给你一个大小为 m x n 的二进制矩阵 grid 。</p>
<p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 1 的单元格的数目。</p>
<p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<img src="../images/%E8%92%9C%E6%B3%95/maxarea1-grid.jpg" alt="img" style="zoom:50%;" />

<p>示例 1：</p>
<p>输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>输出：6<br>解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p>
<p>示例 2：</p>
<p>输入：grid = [[0,0,0,0,0,0,0,0]]<br>输出：0</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>已知：<code>grid(m*n)</code> <code>岛屿是1，水是0</code></p>
<p>要求：最大的岛屿面积<code>ans</code>（四个正方向相邻的1块才属于同一个岛屿）</p>
<p>思路:</p>
<ol>
<li>此题较上题多了一层逻辑，那就是需要自行寻找<code>起始点</code>，我们不妨对grid这个二维数组套用行列遍历</li>
<li>随后进行广搜/深搜</li>
<li>那么这个题，让我们顺一下深搜步骤：<ol>
<li>我们不妨声明一个 名为dfs的 返回ans值的 用来搞递归的 函数</li>
<li>当我们对一个元素进行上下左右搜索时，分别对搜索到的(符合条件的)元素进行上下左右搜索，←的同时对搜索到的元素进行上下左右搜索……</li>
<li>补充一个环节，那就是当搜索的元素不符合条件的时候，return 回溯到上一层（在本题中，返回ans值为0)</li>
</ol>
</li>
</ol>
<p>请直接移移步到大佬写的代码↓</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>优雅太优雅了↓</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大佬的DFS</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> m = grid.<span class="property">length</span>, n = grid[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span> (x, y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[x][y] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ans += <span class="title function_">dfs</span>(x+dx[i], y+dy[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, <span class="title function_">dfs</span>(i, j))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大佬的BFS</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, row = grid.<span class="property">length</span>, col = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dx = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], dy = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>];<span class="comment">//方向数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//循环网格，遇到0就跳过</span></span><br><span class="line">            <span class="keyword">let</span> queue = [[i, j]], curr = <span class="number">0</span>;<span class="comment">//在队列中加入当前网格的值</span></span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> [x, y] = queue.<span class="title function_">shift</span>();<span class="comment">//不断出队</span></span><br><span class="line">              	<span class="comment">//越界判断</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || grid[x][y] === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ++curr;<span class="comment">//更新岛屿的数量</span></span><br><span class="line">                grid[x][y] = <span class="number">0</span>;<span class="comment">//遍历过的网格置为0</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; dx.<span class="property">length</span>; k++) &#123;<span class="comment">//上下左右遍历，把下一层的节点加入队列</span></span><br><span class="line">                    queue.<span class="title function_">push</span>([x + dx[k], y + dy[k]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, curr);<span class="comment">//更新最大岛屿面积</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的BFS——哥们儿就喜欢BFS（等待打脸）</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, m = grid.<span class="property">length</span>, n = grid[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> queue = [&#123;<span class="attr">x</span>: i, <span class="attr">y</span>: j&#125;], s = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> &#123;x, y&#125; = queue.<span class="title function_">shift</span>()</span><br><span class="line">                grid[x][y] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">let</span> newX = x + dx[k], newY = y + dy[k]</span><br><span class="line">                    <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &lt; n &amp;&amp; grid[newX][newY] == <span class="number">1</span>) &#123;</span><br><span class="line">                        queue.<span class="title function_">push</span>(&#123;<span class="attr">x</span>: newX, <span class="attr">y</span>: newY&#125;)</span><br><span class="line">                        grid[newX][newY] = <span class="number">0</span></span><br><span class="line">                        s++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🌲617-合并二叉树"><a href="#🌲617-合并二叉树" class="headerlink" title="🌲617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">🌲617. 合并二叉树</a></h3><blockquote>
<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p>示例 1：</p>
<p>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br>示例 2：</p>
<p>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li><p>我们<code>直接在root1上做修改</code>，我们简称两者为一和二：</p>
<ol>
<li>当仅一为空的时候，递归函数返回二</li>
<li>当仅二为空的时候，递归函数返回一</li>
<li>两者皆空依然返回一</li>
<li>两者都不空，那.val相加</li>
</ol>
</li>
<li><p>调用函数本身，实现节点左右孩子合并</p>
</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1</span><br><span class="line">    &#125;</span><br><span class="line">    root1.<span class="property">val</span> += root2.<span class="property">val</span></span><br><span class="line"></span><br><span class="line">    root1,left = <span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>, root2.<span class="property">left</span>)</span><br><span class="line">    root1.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>, root2.<span class="property">right</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当然也可以新开一个树，不在原树上做更改。</span></span><br></pre></td></tr></table></figure>

<h3 id="👉116-填充每个节点的下一个右侧节点指针"><a href="#👉116-填充每个节点的下一个右侧节点指针" class="headerlink" title="👉116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">👉116. 填充每个节点的下一个右侧节点指针</a></h3><blockquote>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="title class_">Node</span> &#123;</span><br><span class="line">  int val;</span><br><span class="line">  <span class="title class_">Node</span> *left;</span><br><span class="line">  <span class="title class_">Node</span> *right;</span><br><span class="line">  <span class="title class_">Node</span> *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例 1：</p>
<img src="../images/%E8%92%9C%E6%B3%95/116_sample.png" alt="img" style="zoom:50%;" />

<p>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。<br>示例 2:（注意看这个看着像示例2的示例2）</p>
<p>输入：root = []<br>输出：[]</p>
</blockquote>
<h4 id="解题思路-层次遍历"><a href="#解题思路-层次遍历" class="headerlink" title="解题思路(层次遍历)"></a>解题思路(层次遍历)</h4><p>发现广搜深搜可以变简洁的小思路是先排除无效的，比如示例二这种</p>
<ol>
<li>所以先排除root=null的情况</li>
<li>将根节点放入新开队列中，开始按层遍历</li>
<li>遍历过程中需要完成两项任务：<ol>
<li>同层next赋值</li>
<li>将下一层增加到队列中</li>
</ol>
</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">const</span> queue = [root]</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                node.<span class="property">next</span> = queue[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有一种直接用.next</span></span><br><span class="line"><span class="comment">// node.right.next = node.left    node.right.next = node.next.left</span></span><br></pre></td></tr></table></figure>

<h3 id="🍊994-腐烂的橘子"><a href="#🍊994-腐烂的橘子" class="headerlink" title="🍊994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🍊994. 腐烂的橘子</a></h3><blockquote>
<p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p>
<p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<p>示例 1：</p>
<p>输入：grid = [[2,1,1],[1,1,0],[0,1,1]]<br>输出：4<br>示例 2：</p>
<p>输入：grid = [[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：</p>
<p>输入：grid = [[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
</blockquote>
<h4 id="解题思路-BFS"><a href="#解题思路-BFS" class="headerlink" title="解题思路(BFS)"></a>解题思路(BFS)</h4><ol>
<li>与烂橘子相邻的好橘子会在一分钟后腐烂</li>
<li>假设最开始所有的烂橘子是第0层，那么隔一分钟烂一层（其下层就是其上下左右方向的好橘子）</li>
<li>如果<code>存在不挨着任何一个烂橘子的好橘子</code>，返回-1；如果到最后<code>都烂了</code>，返回层数；如果<code>一开始没有好橘子</code>，返回0</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="comment">// 好果子耶！</span></span><br><span class="line">    <span class="keyword">let</span> fresh = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 框定边界</span></span><br><span class="line">    <span class="keyword">const</span> row = grid.<span class="property">length</span>, col = grid[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="comment">// 工具队列（专门盛放烂橘子）</span></span><br><span class="line">    <span class="keyword">let</span> que = []</span><br><span class="line">    <span class="comment">// 遍历筐内所有橘子，好的fresh+1，坏的添加到队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                fresh++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">                que.<span class="title function_">push</span>([i, j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 位移数组</span></span><br><span class="line">    <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 找不到坏果子就不算0层（-1层）</span></span><br><span class="line">    <span class="keyword">let</span> cnt = -<span class="number">1</span></span><br><span class="line">    <span class="comment">// 按层遍历</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 层数+1</span></span><br><span class="line">        cnt++</span><br><span class="line">        <span class="comment">// 每层烂橘子个数</span></span><br><span class="line">        <span class="keyword">let</span> size = que.<span class="property">length</span></span><br><span class="line">        <span class="comment">// 遍历cnt层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 去除一个当做父节点</span></span><br><span class="line">            <span class="keyword">let</span> [x, y] = que.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="comment">// 寻找自己的上下左右孩子（感染对象）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">let</span> newX = x + dx[j], newY = y + dy[j]</span><br><span class="line">                <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newY &lt; <span class="number">0</span> || newX &gt;= row || newY &gt;= col || grid[newX][newY] !== <span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">// 找到一个感染对象！把它感染，并放进队列，好橘子个数fresh-1</span></span><br><span class="line">                grid[newX][newY] = <span class="number">2</span></span><br><span class="line">                que.<span class="title function_">push</span>([newX, newY])</span><br><span class="line">                fresh--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有好橘子-1；如果一开始就没好橘子0；好橘子都没了cnt</span></span><br><span class="line">    <span class="keyword">return</span> fresh &gt; <span class="number">0</span> ? -<span class="number">1</span> : (cnt &lt;= <span class="number">0</span> ? <span class="number">0</span> : cnt)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="？🎛542-01-矩阵"><a href="#？🎛542-01-矩阵" class="headerlink" title="？🎛542. 01 矩阵"></a>？<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/01-matrix/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">🎛542. 01 矩阵</a></h3><blockquote>
<p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p>示例 1：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/1626667201-NCWmuP-image.png" alt="img"></p>
<p>输入：mat = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：[[0,0,0],[0,1,0],[0,0,0]]<br>示例 2：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/1626667205-xFxIeK-image.png" alt="img"></p>
<p>输入：mat = [[0,0,0],[0,1,0],[1,1,1]]<br>输出：[[0,0,0],[0,1,0],[1,2,1]]</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>此题用的动态规划</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">mat</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> updateMatrix = <span class="keyword">function</span>(<span class="params">mat</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mat.<span class="property">length</span> || !mat[<span class="number">0</span>].<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> row = mat.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> col = mat[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="keyword">new</span> <span class="title class_">Array</span>(row)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        ans[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(col).<span class="title function_">fill</span>(row + col)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans[i][j], ans[i - <span class="number">1</span>][j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans[i][j], ans[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                ans[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans[i][j], ans[i + <span class="number">1</span>][j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                ans[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans[i][j], ans[i][j + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归-迭代"><a href="#递归-迭代" class="headerlink" title="递归/迭代"></a>递归/迭代</h2><p>有的时候真的不理解递归，所以不喜欢用</p>
<p>但是多做几个就觉得很有成就感，又喜欢用了</p>
<h3 id="👈️206-反转链表"><a href="#👈️206-反转链表" class="headerlink" title="👈️206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">👈️206. 反转链表</a></h3><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<p><img src="../images/%E8%92%9C%E6%B3%95/rev1ex1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
</blockquote>
<h4 id="解题思路-递归"><a href="#解题思路-递归" class="headerlink" title="解题思路(递归)"></a>解题思路(递归)</h4><img src="../images/%E8%92%9C%E6%B3%95/image-20230321184400708.png" alt="image-20230321184400708" style="zoom: 80%;" />

<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.<span class="property">next</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newHead = <span class="title function_">reverseList</span>(head.<span class="property">next</span>);</span><br><span class="line">    head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> curr = head</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = curr.<span class="property">next</span></span><br><span class="line">        curr.<span class="property">next</span> = prev</span><br><span class="line"></span><br><span class="line">        prev = curr</span><br><span class="line">        curr = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🙏21-合并两个有序链表"><a href="#🙏21-合并两个有序链表" class="headerlink" title="🙏21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🙏21. 合并两个有序链表</a></h3><p>递归我的递归啊T_T</p>
<blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：</p>
<img src="../images/%E8%92%9C%E6%B3%95/merge_ex1.jpg" alt="img" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li>当l1为空时返回剩下的l2</li>
<li>当l2为空时返回剩下的l1</li>
<li>当两者都不为空时，要继续递归，如果l1.val &lt;= l2.val，那么递归参数将是(l1的下一个节点, l2)，返回l1</li>
<li>同理l2.val较小时递归l1与l2.next，返回l2</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!list2) <span class="keyword">return</span> list1</span><br><span class="line">    <span class="keyword">if</span> (!list1) <span class="keyword">return</span> list2</span><br><span class="line">    <span class="keyword">if</span> (list1.<span class="property">val</span> &lt;= list2.<span class="property">val</span>) &#123;</span><br><span class="line">        list1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(list1.<span class="property">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(list1, list2.<span class="property">next</span>)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归/回溯"></a>递归/回溯</h2><p>用熟了就有点喜欢用了</p>
<h3 id="👩‍👩‍👧‍👧46-全排列"><a href="#👩‍👩‍👧‍👧46-全排列" class="headerlink" title="👩‍👩‍👧‍👧46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">👩‍👩‍👧‍👧46. 全排列</a></h3><blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>示例 2：</p>
<p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p>
<p>示例 3：</p>
<p>输入：nums = [1]<br>输出：[[1]]</p>
</blockquote>
<h4 id="解题思路-回溯-DFS"><a href="#解题思路-回溯-DFS" class="headerlink" title="解题思路(回溯 DFS)"></a>解题思路(回溯 DFS)</h4><ol>
<li>DFS建树，排除重复重复解，搜出所有解</li>
<li>回溯入口：空数组传入</li>
<li>回溯过程：遍历数字（枚举各项），使用条件判断跳过剪枝项，将符合条件的项添加到数组中，进行下一次迭代选择</li>
<li>回溯出口：数组长度与定长长度一致</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">const</span> used = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">path</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> == nums.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(path.<span class="title function_">slice</span>())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[num]) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            path.<span class="title function_">push</span>(num)</span><br><span class="line">            used[num] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_">dfs</span>(path)</span><br><span class="line"></span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">            used[num] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="👪️77-组合"><a href="#👪️77-组合" class="headerlink" title="👪️77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">👪️77. 组合</a></h3><blockquote>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。 </p>
<p>示例 1：</p>
<p>输入：n = 4, k = 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>示例 2：</p>
<p>输入：n = 1, k = 1<br>输出：[[1]]</p>
</blockquote>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>大同小异，不过要注意此题要求的排列完全解不包含重复元素的不同排列(1,2  2,1 nono!)</p>
<p>所以我们需要通过控制枚举起点start，来正确裁剪分支</p>
<ol>
<li>回溯起点：枚举起点1，空数组</li>
<li>回溯终点：队列长度与要求长度相等</li>
<li>回溯过程：枚举起点start在每一次迭代时+1</li>
</ol>
<p><img src="../images/%E8%92%9C%E6%B3%95/1599556747-PAzUfe-image.png" alt="image.png"></p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">start, que</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (que.<span class="property">length</span> == k) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(que.<span class="title function_">slice</span>())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key = start; key &lt;= n; key++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.<span class="title function_">has</span>(key)) <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            que.<span class="title function_">push</span>(key)</span><br><span class="line">            used.<span class="title function_">set</span>(key)</span><br><span class="line">            </span><br><span class="line">            <span class="title function_">dfs</span>(key+<span class="number">1</span>, que)</span><br><span class="line">            </span><br><span class="line">            used.<span class="title function_">delete</span>(key)</span><br><span class="line">            que.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">1</span>, [])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🔠784-字母大小写全排列"><a href="#🔠784-字母大小写全排列" class="headerlink" title="🔠784. 字母大小写全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🔠784. 字母大小写全排列</a></h3><blockquote>
<p>给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。</p>
<p>返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。</p>
<p>示例 1：</p>
<p>输入：s = “a1b2”<br>输出：[“a1b2”, “a1B2”, “A1b2”, “A1B2”]<br>示例 2:</p>
<p>输入: s = “3z4”<br>输出: [“3z4”,”3Z4”]</p>
</blockquote>
<h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p>可恶！！！数字！！！！树树树！！！！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">start, que</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (que.<span class="property">length</span> == len) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(que.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="title function_">charAt</span>(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.<span class="title function_">charAt</span>(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到数字pushpushdfs</span></span><br><span class="line">                que.<span class="title function_">push</span>(s.<span class="title function_">charAt</span>(i))</span><br><span class="line">                <span class="title function_">dfs</span>(i+<span class="number">1</span>, que)</span><br><span class="line">                que.<span class="title function_">pop</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遇到字母pushpushdfsdfs</span></span><br><span class="line">                que.<span class="title function_">push</span>(s.<span class="title function_">charAt</span>(i).<span class="title function_">toLowerCase</span>())</span><br><span class="line">                <span class="title function_">dfs</span>(i+<span class="number">1</span>, que)</span><br><span class="line">                que.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line">                que.<span class="title function_">push</span>(s.<span class="title function_">charAt</span>(i).<span class="title function_">toUpperCase</span>())</span><br><span class="line">                <span class="title function_">dfs</span>(i+<span class="number">1</span>, que)</span><br><span class="line">                que.<span class="title function_">pop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我有点不能接收其他思路的感觉，很可怕</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  s = s.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  <span class="keyword">let</span> arr = [s[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>].<span class="title function_">charCodeAt</span>() &gt; <span class="number">96</span>) arr.<span class="title function_">push</span>(s[<span class="number">0</span>].<span class="title function_">toUpperCase</span>())</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">word</span> =&gt;</span> word += s[i])</span><br><span class="line">    <span class="keyword">if</span> (s[i].<span class="title function_">charCodeAt</span>() &gt; <span class="number">96</span>) arr = arr.<span class="title function_">concat</span>(arr.<span class="title function_">map</span>(<span class="function"><span class="params">word</span> =&gt;</span> word.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>) + s[i].<span class="title function_">toUpperCase</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：alexYang</span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//leetcode.cn/problems/letter-case-permutation/solution/by-alexyang-wzkk/</span></span><br><span class="line">来源：力扣（<span class="title class_">LeetCode</span>）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方核武器版本</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">arr, pos, res</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; arr.<span class="property">length</span> &amp;&amp; <span class="title function_">isDigit</span>(arr[pos])) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos === arr.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos] = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(arr[pos].<span class="title function_">charCodeAt</span>() ^ <span class="number">32</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(arr, pos + <span class="number">1</span>, res);</span><br><span class="line">        arr[pos] = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(arr[pos].<span class="title function_">charCodeAt</span>() ^ <span class="number">32</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(arr, pos + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([...s], <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isDigit</span> = (<span class="params">ch</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(ch).<span class="title function_">toString</span>() === <span class="string">&quot;NaN&quot;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：<span class="title class_">LeetCode</span>-<span class="title class_">Solution</span></span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//leetcode.cn/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetco-cwpx/</span></span><br><span class="line">来源：力扣（<span class="title class_">LeetCode</span>）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>自下而上的超牛思想，使问题简单，促人生成功(doge)</p>
</blockquote>
<h3 id="🛤️70-爬楼梯"><a href="#🛤️70-爬楼梯" class="headerlink" title="🛤️70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xh275yye">🛤️70. 爬楼梯</a></h3><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>示例 2：</p>
<p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><p>有两种方式上楼：一次迈一阶/一次迈两阶</p>
<p>最后一次上楼还剩 一阶/两阶</p>
<p>最近一次上楼方式总数 应该是 在此之前两种方式上楼方式的总和<br>$$<br>f(x) = f(x - 1) + f(x - 2)<br>$$<br>用脚趾推算得f(0) = f(1) = 1</p>
<p>那么接下来就可以遍历相加了</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, step1 = <span class="number">1</span>, step2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        step2 = step1</span><br><span class="line">        step1 = ans</span><br><span class="line">        ans = step1 + step2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组更适合我这种笨笨脑</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + ans[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🗼120-三角形最小路径和"><a href="#🗼120-三角形最小路径和" class="headerlink" title="🗼120. 三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">🗼120. 三角形最小路径和</a></h3><blockquote>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<p>示例 1：</p>
<p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>示例 2：</p>
<p>输入：triangle = [[-10]]<br>输出：-10</p>
</blockquote>
<h4 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h4><p>浅画草图</p>
<img src="../images/%E8%92%9C%E6%B3%95/IMG_20230323_091839.jpg" alt="IMG_20230323_091839" style="zoom: 15%;" />

<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">triangle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minimumTotal = <span class="keyword">function</span>(<span class="params">triangle</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> row = triangle.<span class="property">length</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (row === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            triangle[i][j] += <span class="title class_">Math</span>.<span class="title function_">min</span>(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="🕲198-打家劫舍"><a href="#🕲198-打家劫舍" class="headerlink" title="🕲198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">🕲198. 打家劫舍</a></h3><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<h4 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote>
<p> 2  1  1  2</p>
</blockquote>
<p>就是说问题可以拆分成两种情况↓：</p>
<ul>
<li>偷这个家-前头那家不能偷 (小偷溜达到这家，手里有<code>前几家的米，并且攥了一把这家的米</code>)</li>
<li>偷前头那家-这家不能偷 (小偷溜达到这家的时候，手里有偷<code>前前头那几家的米</code>)</li>
</ul>
<p>所以说状态量应该是：小偷溜达到第几家的时候手里有多少米</p>
<p>最终解是俩两种情况里挑最大的↓</p>
<blockquote>
<p>2                    1                    1                    2</p>
<p><strong>偷2</strong>不偷0      偷1<strong>不偷2</strong>      <strong>偷3</strong>不偷2      <strong>偷4</strong>不偷3</p>
</blockquote>
<p>那么↓</p>
<p>$home[x] = max(home[x-1], home[x-2] + money[x])$</p>
<p>小偷我到这家手里的钱钱 = 上一家偷来的钱钱 / 这家偷的钱钱和非上一家偷来的钱钱之和  (聪明的小偷会选择较大的获益)</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> dp = [nums[<span class="number">0</span>], <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态压缩</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp_0 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> dp_1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">let</span> dp_max = dp_1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp_max = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp_1, dp_0 + nums[i])</span><br><span class="line">        dp_0 = dp_1</span><br><span class="line">        dp_1 = dp_max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp_max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1️⃣191-位1的个数"><a href="#1️⃣191-位1的个数" class="headerlink" title="1️⃣191. 位1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">1️⃣191. 位1的个数</a></h3><blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（汉明重量）。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。</p>
<p>示例 1：</p>
<p>输入：n = 00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p>
<p>输入：n = 00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p>
<p>输入：n = 11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
</blockquote>
<h4 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察：<code>n &amp; (n - 1) = 把n的二进制位中最低位的1变为0后的结果</code></p>
<p>也就是说我们只需要  不断把二进制数中的1=&gt;0，直到数字变为0  就可以求得其“汉明重量/汉明权重”</p>
<blockquote>
<p>​        汉明权重是一串符号中不同于（定义在其所使用的字符集上的）零符号（zero-symbol）的个数。对于一个二进制数，它的汉明权重就等于它 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="1"> 的个数（即 <code>popcount</code>)。</p>
</blockquote>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> popCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span></span><br><span class="line">        popCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> popCount</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2️⃣231-2-的幂"><a href="#2️⃣231-2-的幂" class="headerlink" title="2️⃣231. 2 的幂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-two/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">2️⃣231. 2 的幂</a></h3><blockquote>
<p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>
<p>示例 1：</p>
<p>输入：n = 1<br>输出：true<br>解释：20 = 1<br>示例 2：</p>
<p>输入：n = 16<br>输出：true<br>解释：24 = 16<br>示例 3：</p>
<p>输入：n = 3<br>输出：false<br>示例 4：</p>
<p>输入：n = 4<br>输出：true<br>示例 5：</p>
<p>输入：n = 5<br>输出：false</p>
</blockquote>
<h4 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h4><p>我对位运算没太有概念啊，反正遇到一个题就记一下了</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) === <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (-n)) === n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔢136-只出现一次的数字"><a href="#🔢136-只出现一次的数字" class="headerlink" title="🔢136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">🔢136. 只出现一次的数字</a></h3><blockquote>
<p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p>示例 1 ：</p>
<p>输入：nums = [2,2,1]<br>输出：1<br>示例 2 ：</p>
<p>输入：nums = [4,1,2,1,2]<br>输出：4<br>示例 3 ：</p>
<p>输入：nums = [1]<br>输出：1</p>
</blockquote>
<h4 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h4><p>异或运算⊕有以下三个性质:</p>
<ol>
<li>$a ⊕ 0 = a$</li>
<li>$a⊕a = 0$</li>
<li>$ a ⊕ b ⊕ a = b ⊕ a ⊕ a = b ⊕ (a ⊕ a) = b ⊕ 0 = b $</li>
</ol>
<p>所以只需要遍历数组，把所有的数进行异或，就可以找出只出现一次的数值。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        ans ^= n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="️⃣190-颠倒二进制位"><a href="#️⃣190-颠倒二进制位" class="headerlink" title="#️⃣190. 颠倒二进制位"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-bits/?envType=study-plan&id=suan-fa-ru-men&plan=algorithms&plan_progress=xxlqfn67">#️⃣190. 颠倒二进制位</a></h3><blockquote>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<p>示例 1：</p>
<p>输入：n = 00000010100101000001111010011100<br>输出：964176192 (00111001011110000010100101000000)<br>解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：</p>
<p>输入：n = 11111111111111111111111111111101<br>输出：3221225471 (10111111111111111111111111111111)<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</p>
</blockquote>
<h4 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h4><p>根据位运算特性，遍历各位，逐位颠倒。</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125; - a positive integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBits = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个是运用JS内置一些API做的，但是效率不及后者</span></span><br><span class="line">    <span class="comment">// return +(&#x27;0b&#x27;+n.toString(2).padStart(32,0).split(&#x27;&#x27;).reverse().join(&#x27;&#x27;))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> rev = <span class="number">0</span> <span class="comment">// 初始化一个放各位数的容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n &gt; <span class="number">0</span>; i++) &#123;  <span class="comment">// 对n进行取数位移操作</span></span><br><span class="line">        rev |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - <span class="number">1</span>)  <span class="comment">// 取出n中最后一位数，并将该数放进dev指定位置</span></span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>  <span class="comment">// n无符号向右移动一位捏嘿</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">// 一开始没加&gt;&gt;&gt;0，报错了，错误案例是一个负数，我？？？ </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 还有一种方法是‘位运算分治’我不太理解，偶数对调隔2对调隔4对调什么的</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ra-liz.github.io">Ra-liz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ra-liz.github.io/post/dd4.html">https://ra-liz.github.io/post/dd4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ra-liz.github.io" target="_blank">Ra-Liz's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a><a class="post-meta__tags" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a><a class="post-meta__tags" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a><a class="post-meta__tags" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a><a class="post-meta__tags" href="/tags/BFS/">BFS</a><a class="post-meta__tags" href="/tags/DFS/">DFS</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/d0c6.html" title="速通蓝桥杯Web"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">速通蓝桥杯Web</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ra-liz</div><div class="author-info__description">食栗至上</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ra-Liz"><i class="fab fa-github"></i><span>俺的GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center">微信号：raliz2333</p> <p align="center">QQ号：2879055132</p> <em align="center">请注明来意</em></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.</span> <span class="toc-text">704. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">278. 第一个错误的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">35. 搜索插入位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">2.1.</span> <span class="toc-text">977. 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">189. 轮转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.3.</span> <span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">344. 反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III"><span class="toc-number">2.6.</span> <span class="toc-text">557. 反转字符串中的单词 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">876. 链表的中间结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.8.</span> <span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">567. 字符串的排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS-DFS"><span class="toc-number">4.</span> <span class="toc-text">BFS&#x2F;DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="toc-number">4.1.</span> <span class="toc-text">🧩733. 图像渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">4.1.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8F%9D695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">4.2.</span> <span class="toc-text">🏝695. 岛屿的最大面积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%B2617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.3.</span> <span class="toc-text">🌲617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%89116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">👉116. 填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">解题思路(层次遍历)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">4.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8D%8A994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">4.5.</span> <span class="toc-text">🍊994. 腐烂的橘子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-BFS"><span class="toc-number">4.5.1.</span> <span class="toc-text">解题思路(BFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">4.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%9F%F0%9F%8E%9B542-01-%E7%9F%A9%E9%98%B5"><span class="toc-number">4.6.</span> <span class="toc-text">？🎛542. 01 矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-number">4.6.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">4.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.</span> <span class="toc-text">递归&#x2F;迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%88%EF%B8%8F206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">👈️206. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E9%80%92%E5%BD%92"><span class="toc-number">5.1.1.</span> <span class="toc-text">解题思路(递归)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">5.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%99%8F21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.2.</span> <span class="toc-text">🙏21. 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-number">5.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">5.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF"><span class="toc-number">6.</span> <span class="toc-text">递归&#x2F;回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%A9%E2%80%8D%F0%9F%91%A9%E2%80%8D%F0%9F%91%A7%E2%80%8D%F0%9F%91%A746-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">6.1.</span> <span class="toc-text">👩‍👩‍👧‍👧46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E5%9B%9E%E6%BA%AF-DFS"><span class="toc-number">6.1.1.</span> <span class="toc-text">解题思路(回溯 DFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">6.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%AA%EF%B8%8F77-%E7%BB%84%E5%90%88"><span class="toc-number">6.2.</span> <span class="toc-text">👪️77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-number">6.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">6.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A0784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">6.3.</span> <span class="toc-text">🔠784. 字母大小写全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-number">6.3.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">6.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A4%EF%B8%8F70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">7.1.</span> <span class="toc-text">🛤️70. 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-number">7.1.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-number">7.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%97%BC120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">7.2.</span> <span class="toc-text">🗼120. 三角形最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-number">7.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-number">7.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%95%B2198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">7.3.</span> <span class="toc-text">🕲198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-number">7.3.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-number">7.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1️⃣191. 位1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-number">8.1.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-number">8.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3231-2-%E7%9A%84%E5%B9%82"><span class="toc-number">8.2.</span> <span class="toc-text">2️⃣231. 2 的幂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-number">8.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-number">8.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A2136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">8.3.</span> <span class="toc-text">🔢136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-number">8.3.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-number">8.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%B8%8F%E2%83%A3190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="toc-number">8.4.</span> <span class="toc-text">#️⃣190. 颠倒二进制位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="toc-number">8.4.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-number">8.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/dd4.html" title="蒜法">蒜法</a><time datetime="2023-03-20T01:19:27.000Z" title="发表于 2023-03-20 09:19:27">2023-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/d0c6.html" title="速通蓝桥杯Web">速通蓝桥杯Web</a><time datetime="2023-03-10T10:25:00.000Z" title="发表于 2023-03-10 18:25:00">2023-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/e6cd.html" title="JQ速通">JQ速通</a><time datetime="2023-03-10T02:11:34.000Z" title="发表于 2023-03-10 10:11:34">2023-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/584d.html" title="Ajax学习笔记">Ajax学习笔记</a><time datetime="2023-03-07T08:49:22.000Z" title="发表于 2023-03-07 16:49:22">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/251e.html" title="SpringBoot学习笔记">SpringBoot学习笔记</a><time datetime="2023-03-01T01:38:21.000Z" title="发表于 2023-03-01 09:38:21">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ra-liz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Vslpu39tzreWpSvbdqHPQJ8Z-gzGzoHsz',
      appKey: 'igKODRyXdGL92WEdyVW5mtzB',
      avatar: 'monsterid',
      serverURLs: 'https://vslpu39t.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '2bcb720297a7497aae08',
      clientSecret: 'b30d65cb967dcfba7e4413ddd140a2f3c96c1d2a',
      repo: 'Ra-Liz.github.io',
      owner: 'Ra-Liz',
      admin: ['Ra-Liz'],
      id: 'a08d67854652464e605a0b7906c46861',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>